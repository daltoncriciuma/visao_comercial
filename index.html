<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Visão Comercial</title>
<style>
  :root { color-scheme: dark; }
  html, body { margin:0; width:100vw; height:100vh; overflow:hidden;
    background:#000; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

  /* peça central (base 768×1152), sempre no centro */
  .box{
    position:fixed; left:50%; top:50%;
    width:768px; height:1152px;
    transform-origin:50% 50%;
    will-change: transform;
  }
  svg{ width:100%; height:100%; display:block; }

  /* HUD (zoom e recarregar) + carimbo de atualização (canto inf-direito) */
  .hud{
    position:fixed; right:12px; bottom:12px; display:flex; gap:10px; align-items:center;
    background:rgba(0,0,0,.55); border:1px solid rgba(255,255,255,.15);
    padding:8px 12px; border-radius:12px; font-size:14px; backdrop-filter:blur(4px);
  }
  .btn{ cursor:pointer; border:1px solid rgba(255,255,255,.25);
    background:rgba(255,255,255,.08); padding:6px 10px; border-radius:8px; font-weight:600; }
  .btn:hover{ background:rgba(255,255,255,.15); }
  .muted{ opacity:.9 }
</style>
</head>
<body>

  <!-- peça -->
  <div class="box" id="box">
    <svg viewBox="0 0 768 1152" aria-label="Medidor">
      <defs>
        <!-- mesmo caminho para contorno e recorte -->
        <path id="bottlePath"
          d="M260 170 H508 L532 300
             L592 1000
             Q592 1088 384 1125
             Q176 1088 176 1000
             L236 300 Z"/>
        <clipPath id="clipBottle"><use href="#bottlePath"/></clipPath>
        <linearGradient id="liq" x1="0" y1="0" x2="0" y2="1">
          <stop offset="0%"  stop-color="#6bb8ff"/>
          <stop offset="100%" stop-color="#1976d2"/>
        </linearGradient>
      </defs>

      <!-- líquido (recortado) -->
      <g clip-path="url(#clipBottle)">
        <rect id="liquid" x="0" y="1125" width="768" height="0" fill="url(#liq)"/>
        <rect id="shine"  x="0" y="1125" width="768" height="8" fill="rgba(255,255,255,.45)"/>
      </g>

      <!-- contorno -->
      <use href="#bottlePath" fill="none" stroke="#cfe8ff" stroke-width="8"
           filter="drop-shadow(0 10px 30px rgba(25,118,210,.25))"/>

      <!-- rótulos -->
      <text id="labelTop" x="384" y="145"
            text-anchor="middle" font-size="28" font-weight="800" fill="#fff">30</text>
      <text id="labelPct" x="730" y="600"
            text-anchor="end" font-size="22" font-weight="800" fill="#fff">0%</text>
      <text id="labelPts" x="384" y="900"
            text-anchor="middle" font-size="34" font-weight="800" fill="#fff">0,00</text>
    </svg>
  </div>

  <!-- HUD (inclui a data/hora real da planilha no canto inf-direito) -->
  <div class="hud">
    <button class="btn" id="zoomOut">−</button>
    <button class="btn" id="zoomReset">100%</button>
    <button class="btn" id="zoomIn">+</button>
    <button class="btn" id="reloadBtn">Recarregar</button>
    <span class="muted" id="stamp">Atualizado: —</span>
  </div>

<script>
  /* ===== CONFIG ===== */
  // CSV da WEB_DATA (A1=percentual 0..1, B1=última atualização em "yyyy-MM-dd HH:mm")
  const DATA_CSV_URL =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vR24Vx4SCLyGxtnD8X0tYOnBIZJ_Y10BYhYwaESp2Sui60TTEgC13hvPO8vKNtiMYp35L-A9LcGNmHB/pub?gid=256356509&output=csv";

  const PONTOS_MAX = 30;
  const AUTO_RELOAD_MIN = 5;   // 0 = desliga auto-reload
  const PERCENT_DEFAULT = 0.446;  // fallback se CSV falhar
  const BASE_W = 768, BASE_H = 1152;
  const TOP_Y = 300, BOT_Y = 1125; // corpo do frasco
  const BIAS_VH = -6; // sobe/ desce a peça (em % da altura da janela)

  // ===== centro + zoom =====
  let userZoom = 1.00, ZOOM_STEP = 0.08;
  function fit(){
    const vw = window.innerWidth, vh = window.innerHeight;
    const k  = Math.min(vw/BASE_W, vh/BASE_H) * userZoom;
    const biasPx = (BIAS_VH/100) * vh;
    document.getElementById('box').style.transform =
      `translate(-50%, -50%) translateY(${biasPx}px) scale(${k})`;
    document.getElementById('zoomReset').textContent = Math.round(userZoom*100)+'%';
  }
  function zoomIn(){ userZoom = Math.min(2.5, +(userZoom+ZOOM_STEP).toFixed(2)); fit(); }
  function zoomOut(){ userZoom = Math.max(0.5, +(userZoom-ZOOM_STEP).toFixed(2)); fit(); }
  function zoomReset(){ userZoom = 1.00; fit(); }
  window.addEventListener('resize', fit);
  document.getElementById('zoomIn').onclick  = zoomIn;
  document.getElementById('zoomOut').onclick = zoomOut;
  document.getElementById('zoomReset').onclick = zoomReset;
  document.getElementById('reloadBtn').onclick = load;
  window.addEventListener('keydown', e=>{
    if(e.key==='+') zoomIn();
    if(e.key==='-'||e.key==='−') zoomOut();
    if(e.key==='0') zoomReset();
    if(e.key.toLowerCase()==='r') load();
  });

  // ===== util =====
  const two = n => String(n).padStart(2,'0');
  function brFromIso(iso){ // "yyyy-MM-dd HH:mm" -> "dd/MM/yyyy HH:mm"
    const [d,t] = iso.replace('T',' ').split(' ');
    if(!d||!t) return null;
    const [Y,M,D]=d.split('-'), [h,m]=t.split(':');
    if(!(Y&&M&&D&&h&&m)) return null;
    return `${two(+D)}/${two(+M)}/${Y} ${two(+h)}:${two(+m)}`;
  }

  // ===== CSV → {p, lastIso}  =====
  async function fetchData(){
    try{
      const url = DATA_CSV_URL + (DATA_CSV_URL.includes('?')?'&':'?') + 'cb=' + Date.now();
      const txt = await fetch(url).then(r=>r.text());

      // pega primeiro número (0..1) com vírgula ou ponto
      const mNum = txt.match(/-?\d+(?:[.,]\d+)?/);
      const p = mNum ? parseFloat(mNum[0].replace(',','.')) : NaN;

      // pega ISO "yyyy-MM-dd HH:mm" ou "yyyy-MM-ddTHH:mm"
      const mIso = txt.match(/\d{4}-\d{2}-\d{2}[ T]\d{2}:\d{2}/);
      const lastIso = mIso ? mIso[0].replace('T',' ') : null;

      return {
        p: isFinite(p) ? Math.max(0, Math.min(1, p)) : null,
        lastIso
      };
    }catch(e){
      return { p:null, lastIso:null };
    }
  }

  // ===== desenha =====
  function setLevel(p){
    p = Math.max(0, Math.min(1, p));

    const yTop = BOT_Y - (BOT_Y - TOP_Y) * p;
    const h    = BOT_Y - yTop;

    const liq = document.getElementById('liquid');
    const shine = document.getElementById('shine');
    liq.setAttribute('y', yTop);  liq.setAttribute('height', h);
    shine.setAttribute('y', yTop);

    // pontos (centro do azul)
    const pts = (p*PONTOS_MAX).toFixed(2).replace('.', ',');
    const lblPts = document.getElementById('labelPts');
    lblPts.textContent = pts;
    lblPts.setAttribute('y', yTop + h/2);

    // topo (total)
    document.getElementById('labelTop').textContent = PONTOS_MAX;

    // % na linha d’água
    const pct = (p*100).toFixed(2).replace('.', ',') + '%';
    const lblPct = document.getElementById('labelPct');
    lblPct.textContent = pct;
    lblPct.setAttribute('y', Math.max(TOP_Y+24, yTop - 10)); // nunca invade gargalo
  }

  async function load(){
    const {p, lastIso} = await fetchData();
    setLevel(p==null ? PERCENT_DEFAULT : p);

    const stamp = document.getElementById('stamp');
    if(lastIso){
      const br = brFromIso(lastIso);
      stamp.textContent = `Atualizado: ${br ?? lastIso}`;
    }else{
      stamp.textContent = 'Atualizado: —';
    }
  }

  // start
  fit(); load();
  if (AUTO_RELOAD_MIN>0) setInterval(load, AUTO_RELOAD_MIN*60*1000);
</script>
</body>
</html>
